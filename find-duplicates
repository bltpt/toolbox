#!/usr/bin/python3

# find-duplicates: DirPath [Options] -> StdOut
# Purpose: to return a list of duplicate files residing in the
#          directory hierarchy in DirPath.

import hashlib
import os
import argparse
import sys

def hashFile(filePath, algorithm):
    '''hashFile(): Str1 Str2 --> StrA
    Purpose: to hash the file at Str1 with the algorithm of Str2 and
             return its hash as StrA.
    '''
    if algorithm in hashlib.algorithms_guaranteed:
        hasher = getattr(hashlib, algorithm)()
    else:
        raise ValueError("Error: unsupported hash algorithm \"%s\"." % algorithm)

    blocksize = 65536

    with open(filePath, 'rb') as f:
        buf = f.read(blocksize)
        while len(buf) > 0:
            hasher.update(buf)
            buf = f.read(blocksize)

    return(hasher.hexdigest())

def main(pathRoot, algorithm):
    '''main(): Str1 Str2 -> StdOut
    Purpose: to find all duplicate files in directory Str1 using hash
             algorithm Str2, printing their hashes and file paths to
             StdOut.
    '''

    # Need support for -max-depth optional arg.

    # Walk the path at pathRoot, hash each file, check whether hash has
    # been seen, and if not, add to the "seen" dict. If it's already
    # been seen, print the already "seen" one and the one in the
    # current loop.
    seen = dict()

    if os.path.isdir(pathRoot):
        try:
            for dirPath, dirNames, fileNames in os.walk(pathRoot):
                for fileName in fileNames:
                    filePath = dirPath.strip('/')+'/'+fileName
                    hash = hashFile(filePath,algorithm)
                    if hash in seen.keys():
                        if seen[hash]['printed'] == 0:
                            print(hash+"	"+seen[hash]['fullPath'])
                            print(hash+"	"+filePath)
                            seen[hash]['printed'] = 1
                        elif seen[hash]['printed'] == 1:
                            print(hash+"	"+filePath)
                        else:
                            raise Exception("Something went wrong \
                                            in the seen dict.")
                    else:
                        seen[hash] = {'fullPath' : filePath,
                                      'printed' : 0 }
                                  
        except Exception as e:
            print(e)
    else:
        sys.exit("Error: \"%s\" is not a valid directory." % pathRoot)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument("pathRoot",
                        help = "path to a directory",
                        type=str)
    parser.add_argument("-a", "--algorithm",
                        help = "hash algorithm to use. Default is SHA256.",
                        default = 'sha256')
    args = parser.parse_args()
    main(args.pathRoot,args.algorithm)
